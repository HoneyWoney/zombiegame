<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8"/>
  <title>Zombie Game (Nano Armor Use Behavior)</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    canvas { display:block; margin:0 auto; background:#111; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const WIDTH = canvas.width, HEIGHT = canvas.height, FPS = 60;
    const keys = {};
    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup',   e => keys[e.key] = false);

    const assetPaths = { bg:'bg.png', player:'player.png', zombie:'zombie.png', rope:'rope.png', prison:'prison.png', swab:'swab.png', nano:'nano.png' };
    const assets = {};
    let loaded = 0, total = Object.keys(assetPaths).length;
    const SPRITE = { player:40, zombie:30, rope:36, prison:36, swab:36, nano:36 };

    // 이미지 로드
    for (let key in assetPaths) {
      assets[key] = new Image();
      assets[key].src = assetPaths[key];
      assets[key].onload = () => { if (++loaded === total) startGame(); };
    }

    function isColliding(a,b) {
      return !(a.x+a.size < b.x || a.x > b.x+b.size || a.y+a.size < b.y || a.y > b.y+b.size);
    }

    class Player {
      constructor() {
        this.size = SPRITE.player;
        this.x = WIDTH/2 - this.size/2;
        this.y = HEIGHT/2 - this.size/2;
        this.speed = 4;
        this.health = 2;
        this.ropeCount = 0;
        this.nanoCount = 0;
        this.captured = 0;
        this.imprisoned = 0;
        this.score = 0;
        this.invincibleTimer = 0;
      }
      update() {
        if (keys['ArrowLeft']||keys['a']) this.x -= this.speed;
        if (keys['ArrowRight']||keys['d']) this.x += this.speed;
        if (keys['ArrowUp']||keys['w']) this.y -= this.speed;
        if (keys['ArrowDown']||keys['s']) this.y += this.speed;
        this.x = Math.max(0, Math.min(WIDTH - this.size, this.x));
        this.y = Math.max(0, Math.min(HEIGHT - this.size, this.y));
        if (this.invincibleTimer > 0) this.invincibleTimer--;
      }
      draw() {
        if (this.invincibleTimer > 0) {
          if (Math.floor(this.invincibleTimer/15) % 2 === 0) return;
        }
        ctx.drawImage(assets.player, this.x, this.y, this.size, this.size);
      }
    }

    class Zombie {
      constructor() { this.size = SPRITE.zombie; this.reset(); }
      reset() { this.x = Math.random()*(WIDTH-this.size); this.y = Math.random()*(HEIGHT-this.size); this.speed=1.5; }
      update(player) {
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx,dy)||1;
        this.x += this.speed*dx/dist;
        this.y += this.speed*dy/dist;
      }
      draw() { ctx.drawImage(assets.zombie, this.x, this.y, this.size, this.size); }
    }

    class Item {
      constructor(type) { this.type=type; this.size=SPRITE[type]; this.reset(); }
      reset() { this.x = Math.random()*(WIDTH-this.size); this.y = Math.random()*(HEIGHT-this.size); }
      draw() {
        if (this.type === 'rope') ctx.filter = 'brightness(1.3)';
        ctx.drawImage(assets[this.type], this.x, this.y, this.size, this.size);
        ctx.filter = 'none';
      }
    }

    function startGame() {
      const player = new Player();
      const zombies = Array.from({length:5},() => new Zombie());
      let items = Array.from({length:8},() => new Item(randomType()));
      const collected = {rope:0, prison:0, swab:0, nano:0};

      function loop() {
        ctx.drawImage(assets.bg,0,0,WIDTH,HEIGHT);
        player.update(); zombies.forEach(z=>z.update(player));

        // 아이템 충돌 & 리스폰
        items = items.map(it => {
          if (isColliding(player, it)) {
            collected[it.type]++;
            applyItem(it.type, player);
            return new Item(randomType());
          }
          return it;
        });

        // 좀비 충돌 및 처리
        for (let z of zombies) {
          if (isColliding(player, z)) {
            if (player.ropeCount > 0) {
              player.ropeCount--;
              player.captured++;
              z.reset();
              player.invincibleTimer = 3*FPS;
            } else if (player.nanoCount > 0) {
              // 로프 없고 나노옷 있을 경우
              player.nanoCount--;
              player.invincibleTimer = 3*FPS;
              // 좀비는 사라지지 않음
            } else if (player.invincibleTimer === 0) {
              player.health--;
              z.reset();
              if (player.health <= 0) return gameOver(player.score);
              player.invincibleTimer = 3*FPS;
            }
            break;
          }
        }

        // 그리기
        player.draw(); zombies.forEach(z=>z.draw()); items.forEach(it=>it.draw());

        // HUD
        ctx.fillStyle = '#fff'; ctx.font='16px monospace';
        ctx.fillText(
          `체력:${player.health} 로프:${player.ropeCount} 나노옷:${player.nanoCount}`+
          ` 포획:${player.captured} 감옥:${player.imprisoned} 점수:${player.score}`,
          10,20
        );
        ctx.fillText(
          `획득→ 로프:${collected.rope} 감옥:${collected.prison} 면봉:${collected.swab} 나노:${collected.nano}`,
          10,40
        );
        requestAnimationFrame(loop);
      }
      loop();
    }

    function applyItem(type, player) {
      if (type === 'rope') player.ropeCount++;
      else if (type === 'prison' && player.captured > 0) { player.imprisoned++; player.captured--; }
      else if (type === 'swab' && player.imprisoned > 0) { player.score++; player.imprisoned--; }
      else if (type === 'nano') player.nanoCount++;
    }

    function randomType() { return ['rope','prison','swab','nano'][Math.floor(Math.random()*4)]; }
    function gameOver(score) { alert(`게임 오버!\n최종 점수: ${score}`); window.location.reload(); }
  </script>
</body>
</html>
