<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8"/>
  <title>Zombie Game (Keyboard, Mouse & Mobile Controls)</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    #gameCanvas { display:block; margin:0 auto; background:#111; touch-action: none; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const WIDTH = canvas.width, HEIGHT = canvas.height, FPS = 60;
    // 입력 상태
    const keys = {};
    let pointerActive = false;
    let pointerX = 0, pointerY = 0;
    
    // 키보드 이벤트
    window.addEventListener('keydown', e => { keys[e.key] = true; });
    window.addEventListener('keyup', e => { keys[e.key] = false; });
    
    // 포인터 이벤트 (마우스 & 터치)
    canvas.addEventListener('pointerdown', e => {
      pointerActive = true;
      const rect = canvas.getBoundingClientRect();
      pointerX = e.clientX - rect.left;
      pointerY = e.clientY - rect.top;
    });
    canvas.addEventListener('pointermove', e => {
      if (pointerActive) {
        const rect = canvas.getBoundingClientRect();
        pointerX = e.clientX - rect.left;
        pointerY = e.clientY - rect.top;
      }
    });
    canvas.addEventListener('pointerup', () => {
      pointerActive = false;
    });
    canvas.addEventListener('pointerleave', () => {
      pointerActive = false;
    });

    // 이미지 로드
    const assetPaths = { bg:'bg.png', player:'player.png', zombie:'zombie.png', rope:'rope.png', prison:'prison.png', swab:'swab.png', nano:'nano.png' };
    const assets = {};
    let loaded = 0, total = Object.keys(assetPaths).length;
    const SPRITE = { player:40, zombie:30, rope:36, prison:36, swab:36, nano:36 };
    for (let key in assetPaths) {
      const img = new Image();
      img.src = assetPaths[key];
      img.onload = () => { if (++loaded === total) startGame(); };
      assets[key] = img;
    }

    // 충돌 검사
    function isColliding(a,b) {
      return !(a.x+a.size < b.x || a.x > b.x+b.size || a.y+a.size < b.y || a.y > b.y+b.size);
    }

    // 플레이어
    class Player {
      constructor() {
        this.size = SPRITE.player;
        this.x = WIDTH/2 - this.size/2;
        this.y = HEIGHT/2 - this.size/2;
        this.speed = 4;
        this.health = 2;
        this.ropeCount = 0;
        this.nanoCount = 0;
        this.captured = 0;
        this.imprisoned = 0;
        this.score = 0;
        this.invincibleTimer = 0;
      }
      update() {
        let dx = 0, dy = 0;
        // 키보드 이동
        if (keys['ArrowLeft']||keys['a']) dx -= this.speed;
        if (keys['ArrowRight']||keys['d']) dx += this.speed;
        if (keys['ArrowUp']||keys['w']) dy -= this.speed;
        if (keys['ArrowDown']||keys['s']) dy += this.speed;
        // 포인터 이동
        if (pointerActive) {
          const centerX = this.x + this.size/2;
          const centerY = this.y + this.size/2;
          const distX = pointerX - centerX;
          const distY = pointerY - centerY;
          const dist = Math.hypot(distX, distY) || 1;
          dx = this.speed * distX / dist;
          dy = this.speed * distY / dist;
        }
        this.x += dx;
        this.y += dy;
        // 경계 내 제한
        this.x = Math.max(0, Math.min(WIDTH - this.size, this.x));
        this.y = Math.max(0, Math.min(HEIGHT - this.size, this.y));
        if (this.invincibleTimer > 0) this.invincibleTimer--;
      }
      draw() {
        // 깜빡임 무적
        if (this.invincibleTimer > 0 && Math.floor(this.invincibleTimer/15) % 2 === 0) return;
        ctx.drawImage(assets.player, this.x, this.y, this.size, this.size);
      }
    }

    // 좀비
    class Zombie {
      constructor() { this.size = SPRITE.zombie; this.reset(); }
      reset() {
        this.x = Math.random()*(WIDTH-this.size);
        this.y = Math.random()*(HEIGHT-this.size);
        this.speed = 1.5;
      }
      update(player) {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx,dy) || 1;
        this.x += this.speed * dx/dist;
        this.y += this.speed * dy/dist;
      }
      draw() { ctx.drawImage(assets.zombie,this.x,this.y,this.size,this.size); }
    }

    // 아이템
    class Item {
      constructor(type) { this.type=type; this.size=SPRITE[type]; this.reset(); }
      reset() { this.x=Math.random()*(WIDTH-this.size); this.y=Math.random()*(HEIGHT-this.size); }
      draw() {
        if (this.type==='rope') ctx.filter='brightness(1.3)';
        ctx.drawImage(assets[this.type],this.x,this.y,this.size,this.size);
        ctx.filter='none';
      }
    }

    // 게임 시작
    function startGame() {
      const player = new Player();
      const zombies = Array.from({length:5},()=>new Zombie());
      let items = Array.from({length:8},()=>new Item(randomType()));
      const collected = {rope:0,prison:0,swab:0,nano:0};
      function loop() {
        // 배경
        ctx.drawImage(assets.bg,0,0,WIDTH,HEIGHT);
        // 업데이트
        player.update();
        zombies.forEach(z=>z.update(player));
        // 아이템 충돌 및 리스폰
        items = items.map(it=>{
          if(isColliding(player,it)){
            collected[it.type]++;
            applyItem(it.type,player);
            return new Item(randomType());
          }
          return it;
        });
        // 좀비 충돌 및 처리
        for(let z of zombies) {
          if(isColliding(player,z)) {
            if(player.ropeCount>0) {
              player.ropeCount--; player.captured++; z.reset(); player.invincibleTimer=3*FPS;
            } else if(player.nanoCount>0) {
              player.nanoCount--; player.invincibleTimer=3*FPS;
            } else if(player.invincibleTimer===0) {
              player.health--; z.reset(); if(player.health<=0) return gameOver(player.score); player.invincibleTimer=3*FPS;
            }
            break;
          }
        }
        // 그리기
        player.draw(); zombies.forEach(z=>z.draw()); items.forEach(it=>it.draw());
        // HUD
        ctx.fillStyle='#fff'; ctx.font='16px monospace';
        ctx.fillText(
          `체력:${player.health} 로프:${player.ropeCount} 나노옷:${player.nanoCount} 포획:${player.captured} 감옥:${player.imprisoned} 점수:${player.score}`,
          10,20);
        ctx.fillText(
          `획득→ 로프:${collected.rope} 감옥:${collected.prison} 면봉:${collected.swab} 나노:${collected.nano}`,
          10,40);
        requestAnimationFrame(loop);
      }
      loop();
    }
    function applyItem(type,player){ if(type==='rope')player.ropeCount++; else if(type==='prison'&&player.captured>0){player.imprisoned++;player.captured--;} else if(type==='swab'&&player.imprisoned>0){player.score++;player.imprisoned--;} else if(type==='nano'){player.nanoCount++;}}    
    function randomType(){ return ['rope','prison','swab','nano'][Math.floor(Math.random()*4)]; }
    function gameOver(score){ alert(`게임 오버!\n최종 점수: ${score}`); window.location.reload(); }
  </script>
</body>
</html>
